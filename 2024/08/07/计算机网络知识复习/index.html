

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="智勇爱学习">
  <meta name="keywords" content="">
  
    <meta name="description" content="HTTP 1.0 和 2.0 有什么区别? HTTP&#x2F;1.0 版本主要增加以下几点:1.增加了 HEAD、POST 等新方法。2.增加了响应状态码。3.引入了头部，即请求头和响应头。4.在请求中加入了 HTTP 版本号。5.引入了 Content-Type ，使得传输的数据不再限于文本。 HTTP&#x2F;1.1 版本主要增加以下几点:1.新增了连接管理即 keepalive ，允许持">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络知识复习">
<meta property="og:url" content="https://zzy-1128.github.io/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="HTTP 1.0 和 2.0 有什么区别? HTTP&#x2F;1.0 版本主要增加以下几点:1.增加了 HEAD、POST 等新方法。2.增加了响应状态码。3.引入了头部，即请求头和响应头。4.在请求中加入了 HTTP 版本号。5.引入了 Content-Type ，使得传输的数据不再限于文本。 HTTP&#x2F;1.1 版本主要增加以下几点:1.新增了连接管理即 keepalive ，允许持">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zzy-1128.github.io/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807105337296.png">
<meta property="og:image" content="https://zzy-1128.github.io/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807111939389.png">
<meta property="og:image" content="https://zzy-1128.github.io/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807150112699.png">
<meta property="og:image" content="https://zzy-1128.github.io/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807151407392.png">
<meta property="og:image" content="https://zzy-1128.github.io/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807151327175.png">
<meta property="og:image" content="https://zzy-1128.github.io/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807152255383.png">
<meta property="article:published_time" content="2024-08-07T02:10:55.000Z">
<meta property="article:modified_time" content="2024-08-07T07:52:49.018Z">
<meta property="article:author" content="智勇爱学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://zzy-1128.github.io/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807105337296.png">
  
  
  
  <title>计算机网络知识复习 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zzy-1128.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机网络知识复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-07 10:10" pubdate>
          August 7, 2024 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.7k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          57 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机网络知识复习</h1>
            
            
              <div class="markdown-body">
                
                <p><strong>HTTP 1.0 和 2.0 有什么区别?</strong></p>
<p>HTTP&#x2F;1.0 版本主要增加以下几点:<br>1.增加了 HEAD、POST 等新方法。<br>2.增加了响应状态码。<br>3.引入了头部，即请求头和响应头。<br>4.在请求中加入了 HTTP 版本号。<br>5.引入了 Content-Type ，使得传输的数据不再限于文本。</p>
<p>HTTP&#x2F;1.1 版本主要增加以下几点:<br>1.新增了连接管理即 keepalive ，允许持久连接。<br>2.支持 pipeline，无需等待前面的请求响应，即可发送第二次请求。<br>3.允许响应数据分块(chunked)，即响应的时候不标明Content-Length，客户端就无法断开连接，直到收到服务端的 EOF，利于传输大文件。<br>4.新增缓存的控制和管理。<br>5.加入了 Host 头，用在你一台机子部署了多个主机，然后多个域名解析又是同一个IP，此时加入了 Host 头就可以判断你到底是要访问哪个主机。</p>
<p>HTTP&#x2F;2 版本主要增加以下几点:<br>1.是二进制协议，不再是纯文本上<br>2.支持一个TCP 连接发起多请求，移除了pipeline。<br>3.利用 HPACK 压缩头部，减少数据传输量。<br>4.允许服务端主动推送数据。</p>
<p><strong>HTTP 2.0 和 3.0 有什么区别?</strong></p>
<p>痛点来自于 HTTP 依赖的 TCP。TCP 是面向可靠的、有序的传输协议，因此会有失败重传和按序机制，而 HTTP&#x2F;2 是所有流共享一个 TCP 连接所以会有 TCP 层面的队头阻塞，当发生重传时会影响多个请求响应。<br>并且 TCP 是基于四元组(源IP，源端口，目标IP，目标端口)来确定连接的，而在移动网络的情况下IP 地址会频繁的换，这会导致反复的建连。<br>还有 TCP 与 TLS 的叠加握手，增加了延时。<br>问题就出在 TCP 身上，所以 Google 就把目光瞄向了 UDP。<br> QUIC 引入了个叫 Connection ID 来标识一个链接，所以切换网络之后可以复用这个连接，达到0RTT 就能开始传输。</p>
<p> HTTP&#x2F;2 提到的 HPACK，这个是依赖 TCP 的可靠、有序传输的，于是 QUC 得搞了个 QPACK，也采用了静态表、动态表和哈夫曼编码。<br>它丰富了 HTTP&#x2F;2 的静态表，从 61 项加到了 98 项。<br>上面提到的动态表，是用来存储末包含在静态表中的头部项，假设动态表还未收到，后面来解头部的时候肯定要被阻塞的。所以 QPACK 就另开一条路，在单向的 Stream 里传输动态表的编解码，单向传输好了，接受端到才能开始解码也就是说还没好你就先别管，防止做一半卡住了。<br>**那还有前面提到的 TCP 队头阻塞， QUIC 是怎么解决的呢?**毕竟它也要保证有序和可靠啊。<br>因为 TCP 不认识每个流分别是哪个请求的，所以它只能全部阻塞住，而 QUIC 知道，因此比如请求 A 丢包了我就把 A卡住了就行，请求 B完全可以全部放行，丝毫不受影响。<br>可以看到基于 UDP 的 QUIC 还是很强大的，而且人家用户多，在 2018 年，互联网标准化组织IETF 提议将 HTTPover QUIc 更名为 HTTP&#x2F;3 并获得批准。</p>
<p><strong>HTTP 和 HTTPS 有什么区别?</strong></p>
<p>http 是明文传输，而 https 是加密传输，所以基本上市面上的网站用的都是 htps 协议，因为明文传输很容易被中间人抓包然后获取一些敏感信息。<br>而加密传输中间人只能获取加密的数据<br>https 是基于http上又加了SSL(Secure Sockets Layer)或TLS(Transport Layer Security)协议来实现的加密传输。<br>https 传输的过程使用对称加密，这比非对称加密更加高效。</p>
<p>端口不一样，http是80，https是443。 https相较于http在三次握手之后还需要进行SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</p>
<p><strong>TCP 是用来解决什么问题?</strong></p>
<p>TCP 即 Transmission Control Protocol，可以看到是一个传输控制协议，<br>控制可靠、按序地传输以及端与端之间的流量控制。拥塞控制，需要为整体网络的情况考虑。</p>
<p><strong>TCP 和 UDP 有什么区别?</strong></p>
<p>tcp 是面向连接的协议，它提供有序、可靠的数据传输，有确认应答、超时重传、流是控制和拥塞控制等机制。<br>udp 是无连接协议，它不保证数据的可靠性，仅传输数据，也不会等待对方的响应，没有顺序、流量和拥塞控制，也因此它的传输速度更快。<br>tcp主要用于可靠传输场景、例如文件传输、电商网站等。<br>udp主要用于游戏、直播等对数据可靠性要求不高的场景。</p>
<p><strong>为什么要 TCP，IP 层实现控制不行么?</strong></p>
<p>我们知道网络是分层实现的，网络协议的设计就是为了通信，从链路层到IP 层其实就已经可以完成通信了。<br>你看链路层不可或缺毕竟咱们电脑都是通过链路相互连接的，然后IP充当了地址的功能，所以通过IP 咱们找到了对方就可以进行通信了。<br>那加个 TCP 层干啥?IP 层实现控制不就完事了嘛?<br>之所以要提取出一个 TCP 层来实现控制是因为IP 层涉及到的设备更多一条数据在网络上传输需要经过很多设备，而设备之间需要靠 IP 来寻址。<br>假设IP 层实现了控制，那是不是涉及到的设备都需要关心很多事情?整体传输的效率是不是大打折扣了?</p>
<p>举个例子，假如 A要传输给F一个积木，但是无法直接传输到，需要经过 B、C、D、E这几个中转站之手。这里有两种情况:<br>假设 BCDE 都需要关心这个积木搭错了没，都拆开包裹仔细的看看，没问题了再装回去，最终到了F的手中。<br>假设 BCDE 都不关心积木的情况，来啥包裹只管转发就完事了，由最终的F自己来检查这个积木答错了没。<br>你觉得哪种效率高?明显是第二种，转发的设备不需要关心这些事，只管转发就完事!<br>所以把控制的逻辑独立出来成 TCP 层，让真正的接收端来处理，这样网络整体的传输效率就高了。</p>
<p><strong>TCP 的粘包和拆包能说说吗?</strong></p>
<p>粘包与半包只有在 TCP 传输的时候才会有，像 UDP 是不会有这种情况的，原因是因为 TCP 是面向流的，数据之间没有界限的，而 UDP 是有的界限的。<br>如果熟悉 TCP 和 UDP 报文格式的同学肯定知道，TCP 的包没有报文长度，而 UDP 的包有报文长度，这也说明了TCP 为什么是流式。<br>所以我为什么说上面的例子不太恰当，因为现实生活中快递的包裹之间其实是有界限的，TCP 则像流水，没有明确的界限。<br>然后 TCP 有发送缓冲区的概念，UDP 实际上是没这个概念。<br>假设 TCP 一次传输的数据大小超过发送缓冲区大小，那么一个完整的报文就需要被拆分成两个或更多的小报文这可能会产生半包的情况，当接收端收到不完整的数据，是无法解析成功的。<br>如果 TCP 一次传输的数据大小小于发送缓冲区，那么可能会跟别的报文合并起来一块发送，这就是粘包。</p>
<p><strong>说说 TCP 的三次握手?</strong></p>
<p><img src="/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807105337296.png" srcset="/img/loading.gif" lazyload alt="image-20240807105337296"></p>
<p>客户端首先发送一个SYN(同步序列编号)消息给服务器，服务器收到后回复一个SYN-ACK(同步序列编号-确认)消息，最后客户端再发送一个ACK(确认)消息确认服务器已经收到SYN-ACK消息，从而完成三次握手，建立起-个可靠的TCP连接。</p>
<p><strong>初始序列号 ISN 怎么取值的?</strong></p>
<p>ISN：初始化序列号（initial sequence number），是在建立tcp三次握手的时候，存储在TCP头部的序列号位置中的数字的代称。也就是说，告诉对方我将要开始发送的初始化序列号是多少，两边都要发这个ISN，即tcp三次握手中第一次握手的SYN包和第二次握手的SYN+ACK包中都有这个数值。这个ISN的具体数值是不固定的。</p>
<p>如果写死一个值，比如0，那么假设已经建立好连接了，client 也发了很多包比如已经第 20 个包了然后网络断了之后 client 重新，端口号还是之前那个，然后序列号又从0开始，此时服务端返回第 20 个包的ack，客户端是不是傻了?<br>所以 RFC793 中认为 ISN 要和一个假的时钟绑定在一起<br>ISN 每四微秒加一，当超过 2的 32 次方之后又从0开始，要四个半小时左右发生ISN 回绕。<br>所以 ISN 变成一个递增值，真实的实现还需要加一些随机值在里面，防止被不法份子猜到 ISN。</p>
<p>初始序列号(ISN)的选取涉及多个考虑因素，包括连接唯一性、防止旧数据包干扰和增强安全性。现代系统通常采用时间戳法、随机化算法或两者结合的方法来生成ISN，以确保连接的可靠性和安全性。通过这些方法，ISN在保证唯一性和不可预测性方面发挥了重要作用，从而有效防止了TCP序列号预测攻击。</p>
<p><strong>SYN 超时了怎么处理?</strong></p>
<p> cient 发送 SYN 至 server 然后就挂了，此时 server 发送 SYN+ACK 就一直得不到回复。想到的就是重试，但是不能连续快速重试多次，假设 client 掉线了，你总得给它点时间恢复吧，所以呢需要慢慢重试，阶梯性重试。<br>在 Linux 中就是默认重试5次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等 32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。</p>
<p><strong>SYN Flood 攻击有听过吗?</strong></p>
<p>SYN 超时需要耗费服务端 63s 的时间断开连接，也就说 63s 内服务端需要保持这个资源，所以不法分子就可以构造出大量的 client 向 server发 SYN 但就是不回 server。</p>
<p>使得 server 的 SYN 队列耗尽，无法处理正常的建连请求。<br>所以怎么办?<br>可以开启 tcp_syncookies，那就用不到 SYN 队列了。SYN 队列满了之后 TCP 根据自己的 ip、端口、然后对方的 ip、端口，对方 SYN 的序号，时间戳等一波操作生成个特殊的序号(即 cookie)发回去，如果对方是正常的 client 会把这个序号发回来，然后 server 根据这个序号建连。<br>或者调整 tcpsynackretries 减少重试的次数，设置 tcpmaxsyn_backlog 增加 SYN 队列数，设置tcp_abortonoverflow SYN 队列满了直接拒绝连接。</p>
<p><strong>说说 TCP 的四次挥手?</strong></p>
<p><img src="/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807111939389.png" srcset="/img/loading.gif" lazyload alt="image-20240807111939389"></p>
<p>当一个方向另一个方向发送了最后一个数据包后，它会发送一个FIN(结束)消息，收到FIN消息的一方会发送个ACK(确认)消息确认收到FIN消息，然后等待对方的ACK消息。当双方都发送了FIN和ACK消息后，连接被关闭。</p>
<p><strong>为什么要四次挥手?</strong></p>
<p>因为 TCP 是全双工协议，也就是说双方都要关闭，每一方都向对方发送 FIN 和回应ACK。<br>就像我对你说我数据发完了，然后你回复好的你收到了。然后你对我说你数据发完了，然后我向你回复我收到<br>了。所以看起来就是四次。<br>从图中可以看到主动关闭方的状态是 FINWAIT1到 FINWAIT2 然后再到 TIMEWAIT，而被动关闭方是 CLOSEWAIT到 LAST ACK。</p>
<p><strong>挥手一定需要四次吗?</strong></p>
<p>假设 client 已经没有数据发送给 server 了，所以它发送 FIN 给 server 表明自己数据发完了，不再发了，如果这时候 server 还是有数据要发送给 client 那么它就是先回复 ack，然后继续发送数据。<br>等 server 数据发送完了之后再向 client 发送 FIN 表明它也发完了，然后等 client 的 ACK 这种情况下就会有四次挥手。<br>那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 cient，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client的 ACK，这样不就三次挥手了?</p>
<p><strong>为什么要有 TIME_WAIT?</strong></p>
<p>断开连接发起方在接受到接受方的 FIN 并回复 ACK之后并没有直接进入 CLOSED 状态，而是进行了一波等待等待时间为 2MSL。<br>MSL是 Maximum Segment Lifetime，即报文最长生存时间，RFC 793 定义的 MSL 时间是2分钟，Linux 实际实现是 30s，那么 2MSL是一分钟。<br>那么为什么要等 2MSL呢?<br>就是怕被动关闭方没有收到最后的 ACK，如果被动方由于网络原因没有到，那么它会再次发送 FIN， 此时如果主动关闭方已经 CLOSED 那就傻了，因此等一会儿。<br>假设立马断开连接，但是又重用了这个连接，就是五元组完全一致，并且序号还在合适的范围内，虽然概率很低但理论上也有可能，那么新的连接会被已关闭连接链路上的一些残留数据干扰，因此给予一定的时间来处理一些残留数据。</p>
<p><strong>超时重传机制是为了解决什么问题?</strong></p>
<p>提到 TCP 要提供可靠的传输，那么网络又是不稳定的如果传输的包对方没收到却又得保证可靠那么就必须重传。<br>TCP 的可靠性是靠确认号的，比如我发给你1、2、3、4这4个包，你告诉我你现在要5那说明前面四个包你都收到了，就是这么回事儿。<br>不过这里要注意，SeqNum 和 ACK 都是以字节数为单位的，也就是说假设你收到了1、2、4 但是3没有收到你不能 ACK 5，如果你回了5 那么发送方就以为你5之前的都收到了。<br>所以只能回复确认最大连续收到包，也就是 3。<br>而发送方不清楚 3、4 这两个包到底是还没到呢还是已经丢了，于是发送方需要等待，这等待的时间就比较讲究了。<br>如果太心急可能 ACK已经在路上了，你这重传就是浪费资源了，如果太散漫，那么接收方急死了，这死鬼怎么还不发包来，我等的花儿都谢了。<br>所以这个等待超时重传的时间很关键，怎么搞?聪明的小伙伴可能一下就想到了，你估摸着正常来回一趟时间是多少不就好了，我就等这么长。<br>这就来回一趟的时间就叫 RTT，即 Round Trip Time，然后根据这个时间制定超时重传的时间 RTO，即Retransmission Timeout.</p>
<p><strong>为什么还需要快速重传机制?</strong></p>
<p>超时重传是按时间来驱动的，如果是网络状况真的不好的情况，超时重传没问题，但是如果网络状况好的时候只是恰巧丢包了，那等这么长时间就没必要。<br>于是又引入了数据驱动的重传叫快速重传，什么意思呢?就是发送方如果连续三次收到对方相同的确认号，那么马上重传数据。<br>因为连续收到三次相同 ACK 证明当前网络状况是 ok的，那么确认是丢包了，于是立马重发，没必要等这么久。</p>
<p><strong>SACK 的引入是为了解决什么问题?</strong></p>
<p>SACK 即 Selective Acknowledgment，它的引入就是为了解决发送方不知道该重传哪些数据的问题我们来看下面的图就知道了。</p>
<p><img src="/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807150112699.png" srcset="/img/loading.gif" lazyload alt="image-20240807150112699"></p>
<p>SACK 就是接收方会回传它已经接受到的数据，这样发送方就知道哪一些数据对方已经收到了，所以就可以选择性的发送丢失的数据。<br>如图，通过 ACK 告知我接下来要 5500 开始的数据，并一直更新 SACK，6000-6500 我收到了，6000-7000的数据我收到了，6000-7500的数据我收到了，发送方很明确的知道，5500-5999的那一波数据应该是丢了，于是重传。<br>而且如果数据是多段不连续的，SACK 也可以发送，比如 SACK0-500,1000-1500，2000-2500。就表明这几段已经收到了。</p>
<p>D-SACK 其实是 SACK 的扩展，它利用 SACK 的第一段来描述重复接受的不连续的数据序号,如果第一段描述的范围被 ACK 覆盖，说明重复了，比如我都 ACK 到6000了你还给我回 SACK 5000-5500 呢?<br>说白了就是从第一段的反馈来和已经接受到的 ACK比一比，参数是 tcp_dsack，Linux 2.4之后默认开启。<br>那知道重复了有什么用呢?<br>1)知道重复了说明对方收到刚才那个包了，所以是回来的 ACK 包丢了。<br>2)是不是包乱序的，先发的包后到?<br>3)是不是自己太着急了，RTO 太小了?<br>4)是不是被数据复制了，抢先一步呢?</p>
<p><strong>滑动窗口的作用是什么?</strong></p>
<p> TCP 有序号，并且还有重传，但是这还不够，还需要根据情况来控制一下发送速率，因为网络是复杂多变的，有时候就会阻塞住，而有时候又很通畅。<br>所以发送方需要知道接收方的情况，好控制一下发送的速率，不至于蒙着头一个劲儿的发然后接受方都接受不过来。<br>因此 TCP 就有个叫滑动窗口的东西来做流量控制，也就是接收方告诉发送方我还能接受多少数据，然后发送方就可以根据这个信息来进行数据的发送,<br>以下是发送方维护的窗口，就是黑色圈起来的。<img src="/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807151407392.png" srcset="/img/loading.gif" lazyload alt="image-20240807151407392"></p>
<p><img src="/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807151327175.png" srcset="/img/loading.gif" lazyload alt="image-20240807151327175"></p>
<p><strong>已经有滑动窗口了为什么还要拥塞控制?</strong></p>
<p>加了拥塞控制是因为 TCP 不仅仅就管两端之间的情况，还需要知晓一下整体的网络情形，毕竟只有大家都守规矩了道路才会通畅。<br>前面我们提到了重传，如果不管网络整体的情况，肯定就是对方没给 ACK，那我就无脑重传。如果此时网络状况很差，所有的连接都这样无脑重传，是不是网络情况就更差了，更加拥堵了，所以需要个拥塞控制，来避免这种情况的发送。</p>
<p><strong>说说拥塞控制的步骤?</strong></p>
<p>主要有以下几个步骤来搞:<br>1)慢启动，探探路。<br>2)拥塞避免，感觉差不多了减速看看<br>3)拥塞发生快速重传&#x2F;恢复</p>
<p><img src="/2024/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/image-20240807152255383.png" srcset="/img/loading.gif" lazyload alt="image-20240807152255383"></p>
<p>慢启动，就是新司机上路慢慢来，初始化cwnd(Congestion Window)为1，然后每收到一个 ACK 就 cwnd++并且每过一个RTT，cwnd&#x3D;2*cwnd。<br>线性中带着指数，指数中又夹杂着线性增。<br>然后到了一个阈值，也就是 ssthresh(slow start threshold)的时候就进入了拥塞避免阶段。<br>这个阶段是每收到一个 ACK 就 cwnd&#x3D; cwnd + 1&#x2F;cwnd并且每-个 RTT 就 cwnd++。<br>可以看到都是线性增。<br>然后就是一直增，直到开始丢包的情况发生，前面已经分析到重传有两种，!，一种是超时重传，一种是快速重传。<br>如果发生超时重传的时候，那说明情况有点糟糕，于是直接把 ssthresh 置为当前 cwnd 的一半，然后 cwnd 直接变为 1，进入慢启动阶段。<br>如果是快速重传，那么这里有两种实现，一种是 TCP Tahoe ，和超时重传一样的处理。<br>一种是 TCP Reno，这个实现是把 cwnd&#x3D;cwnd&#x2F;2 ，然后把 ssthresh 设置为当前的 cwnd<br>然后进入快速恢复阶段，将cwnd&#x3D; cwnd+3(因为快速重传有三次)，重传 DACK指定的包，如果再收到一个DACK则 cwnd++，如果收到是正常的 ACK 那么就将 cwnd 设为 ssthresh 大小，进入拥塞避免阶段。<br>可以看到快速恢复就重传了指定的一个包，那有可能是很多包都丢了，然后其他的包只能等待超时重传，超时重传就会导致 cwnd 减半，多次触发就指数级下降。<br>所以又搞了个 New Reno，多加了个New，它是在没有SACK的情况下改进快速恢复，它会观察重传 DACK 指定的包的响应 ACK 是否是已,经发送的最大 ACK，比如你发了1、2、3、4，对方没收到 2，但是 3、4都收到了，于是你重传 2 之后 ACK 肯定是 5，说明就丢了这一个包。<br>不然就是还有其他包丢了，如果就丢了一个包就是之前的过程一样，如果还有其他包丢了就继续重传，直到 ACK是全部的之后再退出快速恢复阶段。<br>简单的说就是一直探测到全部包都收到了再结束这个环节。<br>还有个 FACK，它是基于 SACK 用来作为重传过程中的拥赛控制，相对于上面的 New Reno 我们就知道它有 SACK所以不需要一个一个试过去。</p>
<p><strong>ARP 和 RARP 分别是什么?有什么区别?</strong></p>
<p>ARP(Address Resolution Protocol)将IP 地址转换为 MAC 地址，因为最终需要找到 MAC 地址才能跟具体的设<br>备通信。而 RARP(Reverse Address Resolution Protocol)用于将 MAC 地址转换为IP 地址，比如一些设备启动的时候,需要根据 RARP 来得知分配给它的ip 是什么。</p>
<p>ARP协议的工作原理<br>1.获取目标设备的IP地址,<br>2.检查自己的ARP缓存表，如果查到了对应的MAC地址，则直接发送数据包.<br>3.发送ARP请求，包含自己的IP地址，MAC地址，以及需要解析的IP地址，广播到局域网中所有设备。<br>4.目标收到ARP请求后，首先会检查请求的IP地址是否与自己的IP地址匹配，如匹配，则创建ARP响应消息，将自己的IP地址及对应的MAC地址返回给请求方。<br>5.当ARP请求方收到了ARP响应，会更新自己的ARP缓存，将目标IP及对应的MAC写入ARP缓存表:</p>
<p><strong>TCP&#x2F;IP 四层模型是什么?</strong></p>
<p>四层主要指的是:网络接口层、互联网层、传输层和应用层。<br>网络接口层负责在计算机和网络硬件之间传输数据<br>互联网层(网络层)通过IP 协议提供数据包的路由和转发<br>传输层通过 TCP 和 UDP 协议提供端到端的通信服务<br>应用层通过各种协议提供网络应用程序的功能，如 HTTP等</p>
<p><strong>七层模型是什么?</strong></p>
<p>OSI七层模型是计算机网络通信的标准模型，从底层到顶层依次为:物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。<br>1)物理层，主要描述物理层面的传输，比如光纤、电缆<br>2)数据链路层，可以认为是 MAC 层面相邻节点的传输。<br>3)网络层，IP 层面的寻址、路由。<br>4)传输层，TCP 和 UDP 层的传输<br>5)会话层，负责会话状态的保持、管理与同步，<br>6)表示层，些数据的转化，压缩和编码，<br>7)应用层，http 之类的协议的交互转化:</p>
<p><strong>Cookie、Session、Token 之间有什么区别?</strong></p>
<p>Cookie 存储在浏览器，生命周期可以由服务器端设置。<br>Session 存储在服务器，生命周期由服务器端控制。<br>Token(如JWT)存储在客户端，是一个加密的令牌，可以跨多个会话使用。<br>简单来说，Cookie 和Session 更适合用于单次会话的认证和状态管理，而 Token 更适合用于跨会话的认证和状态管理。</p>
<p><strong>JWT Token 听过吗?</strong></p>
<p>Token(如JWT)其实就是一个加密的令牌，服务端通过一定的方式将用户的信息加密生成一个JT Token，后续客户端带着这个 token 来访问服务端时，服务端可以解密得到对应的用户信息，这样就能进行身份和权限的验证了。</p>
<p><strong>当你在浏览器输入一个域名回车后，会发生什么?</strong></p>
<p>请求将域名解析为对应的IP 地址。DNS 服务器返回简单流程如下:浏览器会向DNS服务器发送一个查询请求，IP 地址后，浏览器使用该IP 地址向服务器发起 HTTP 请求。<br>服务器收到请求后，做对应的处理，且返回相应的网页内容。浏览器接收到网页内容后，解析 HTML、CSSJavaScript 等文件，最终显示网页<br>整个过程涉及到 DNS 解析、HTTP 请求、服务器响应和浏览器解析等步骤。</p>
<p><strong>简单谈谈你对 CDN 的理解?</strong></p>
<p>CDN(Content Delivery Network)是一种分布式网络架构，用于加速互联网内容的分发<br>因为网络传输有距离限制，部署杭州的服务器，不同地区的用户访问得到响应的时长是不一样的，杭州的用户来访问肯定比美国的用户来访问快多了。<br>所以就弄了个 CDN 来加快内容的分发:<br>它通过在全球多个地理位置部署服务器，当用户请求内容时，CDN 会根据用户的地理位置，将请求转发到最近的缓存服务器上。这样可以减少数据传输的延迟，提高用户访问速度，同时减轻源服务器的负载。<br>CDN 通常用于加速静态内容(如图片、视频、静态页面等)的访问，提高网站的性能和用户体验。</p>
<p><strong>简单谈谈你对 DNS 的理解?</strong></p>
<p>DNS(Domain Name System)是一个用于将域名转换为IP 地址的分布式数据库系统<br>它的工作原理是，当用户输入一个域名时，DNS 服务器会查询该域名对应的IP 地址，并将结果返回给用户。这样，用户就可以通过域名访问网站，而不需要记住复杂的IP地址。DNS 的使用简化了网络访问过程，提高了网络通信的效率。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机网络知识复习</div>
      <div>https://zzy-1128.github.io/2024/08/07/计算机网络知识复习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>智勇爱学习</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 7, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/19/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95(%E4%B8%80)/" title="笔试练习记录(一)">
                        <span class="hidden-mobile">笔试练习记录(一)</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
